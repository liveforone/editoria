<h1>Editoria - 모두가 작가가되는</h1>

<h2>소개</h2>
<pre>
글과 사진 한장으로 완성하는 온라인 서적 플랫폼
</pre>

<h2>요구사항</h2>
<pre>
- 스프링 시큐리티를 활용한 로그인/로그아웃
- 파일 업로드가능
- 검색/페이징 가능
- 게시글 좋아요 기능 가능
- 권한에 따른 접근 범위(Spring Security ContextHolder)
- 유저 페이지 존재
- 유저 팔로잉(구독) 가능
- 팔로잉 수, 팔로잉 리스트, 팔로워 수, 팔로워 리스트 존재
- 댓글 기능 가능(등록, 삭제)
- 카테고리
- 이중 게시판 형태
</pre>

<h2>설명</h2>
<pre>
- 작품은 '작가등록'을 하면 글을 쓸 '작가' 권한을 얻는다.
- 작가는 '작품(book)'이라는 표지글을 쓰고 그 안에 내부글(board)를 작성한다. -> 이중 게시판 형태
- '작품(book)'을 쓸때에는 카테고리를 고를 수 있으며 카테고리를 클릭시 해당 카테고리 관련 글만 뜬다.
- 작가를 클릭시 작가가 작성한 '작품(book,표지)'를 볼 수 있다.
- 사용자는 내부글 중 맘에 드는 게시글에 '좋아요'를 누를 수 있다.
- 로그인과 회원가입은 스프링 시큐리티로 진행하였다
- 작품과 카테고리에는 검색과 페이징 처리를 하였다.
- 카테고리 -> 표지 -> 게시글, 즉 다중 게시판 형태이다.
- 사용자는 마음에 드는 작가를 팔로우 할 수 있다.
- 팔로잉 리스트에는 해당 사용자가 팔로우한 사람들이, 팔로워리스트에는 해당 사용자를 팔로우하는 사람들이 뜬다.
- 게시글마다 댓글을 작성할 수 있고, 좋아요를 누를 수있다. 좋아요의 수는 즉각 반영된다.
- 모든 '작품(book)'은 검색가능함.
- '작품(book)'은 수정 가능, 삭제 불가능
</pre>

<h2>게시글 수정</h2>
<pre>
게시글은 '파일'을 가지고 있거나 가지고 있지 않다.
이것 때문에 게시글을 등록(save) 할 때에도 파일이 있으면 saveBoardWithFile메소드를 호출하고
파일이 없다면 saveBoardWithNoFile 이라는 메소드를 각각 호출한다.
<u>문제는 파일을 수정할때 나타난다. 파일 수정은 4가지 종류가 있다.</u>
1. 파일이 있는 경우 파일을 바꾸며 수정
2. 파일이 있는 경우 기존 파일 유지하며 수정(제목, 내용)
3. 파일이 기존에 없었는데 파일을 생성하며 수정
4. 파일이 기존에 없었는데 그대로 유지하며 수정
이런 경우 saveFileName이 null인지 아닌지 판별하며 알맞는 메소드를 서비스 로직에서 호출해야한다.
타임리프는 db에 null인 문자열을 가져올때 "" empty 빈 문자열로 가져온다.
이것이 심각한 문제를 초래하는데, null인줄 알고 null로 판별하게 되면 이것이 null아 아니라 빈 문자열이라
그대로 이 문자열이 saveFileName에 set되어서 db에 빈 문자열의 형태로 저장된다.
이렇게 저장되면 게시글을 클릭시 빈 파일이 뜨게 되고 사용자에게 나쁜 경험을 선사한다.
이런 문제는 isEmpty라는 메소드로 saveFileName을 판별해주면 해결할 수 있게된다.
</pre>

<h2>댓글</h2>
<pre>
댓글의 필드에는 boardNum이 있다.
boardNum은 게시글(board)의 id를 저장한다.
댓글의 조회, 등록은 모두 게시글의 id(boardNum)을 기반으로 동작한다.
유일하게 삭제만 댓글 본인의 id를 기반으로 동작한다.
댓글은 댓글리스트 링크를 걸어 따로 관리하도록 했다.
그 이유는 댓글에 페이징을 거는것은 별로 좋은 선택이 아니고 
페이징이 없기때문에 무한히 늘어나는 댓글 때문에 보기도 좋지않고 
게시글 하나 가져오는 시간 또한 늘어나기 때문이다.
</pre>

<h2>댓글 등록시 update쿼리 나감 - jpa관련 문제</h2>
<pre>
댓글 작성시 유의해야할 사항이 있는데, 그것은 똑같은 사용자가 두번째 댓글 등록시 
insert 쿼리가 나가지 않고 update쿼리가 나가는 것이다.
수정 할 때처럼 id값을 set해주지 않았는데도 update쿼리가 나간다.....(분명 insert가 나가야..)
이 문제는 간단하게 해결할 수 있는데, 저장메소드에서 null을 dto에 set해준다.
마지막에 dto를 엔티티로 변환해서 save쿼리가 나갈때 jpa는 id의 값이 null 즉 없기때문에
새로운 객체로 인식하고 업데이트쿼리가 아닌 inset쿼리를 내보내게된다.
개인적인 생각으론 이미 영속화된 엔티티를 계속 jpa가 물고있어서 그런가...하는 생각이 든다.
<u>향후 더 깊게 찾아보고 더욱 완벽하게 이해할것!</u>
</pre>

<h2>팔로잉</h2>
<pre>
팔로잉은 내가 다른 사람을 팔로우(구독) 하는 것을 의미한다.
팔로잉을 하게되면 두가지 트랜잭션이 발생하고, 두가지 객체가 존재하는데, 
첫째객체는 현재 들어가있는 페이지의 주인(author)
둘째객체는 principal.getName() = 나(me)
following 엔티티에는 me에 두번째객체가, following에 첫번째객체를
follower 엔티티에는 me에 첫번째 객체가, follwer에 두번째 객체를 저장하게된다.
</pre>

<h2>타임리프 url파라미터 처리하기</h2>
<pre>
타임리프에서 url파라미터는 ()로 처리한다. 
/user/board/search(keyword=${keyword}, page={page}) -> ?keyword=t&page=1
</pre>

<h2>비동기 없이 충분히 가능하다</h2>
<pre>
좋아요와 댓글은 맨 밑에 있다. 
그 이유는 당연하게도 글을 다 읽고나서 좋아요를 누르고 댓글을 쓰기 때문이다.
따라서 이 둘을 맨 밑으로 빼서 좋아요를 누르거나 댓글을 등록하여 웹이 리프레시가 되어도
사용자에게 사용자에게 큰 이질감을 선사하지 않게된다.
비동기 없이 동기로도 충분히 사용자가 기분좋게 웹을 사용하며 좋아요버튼이나, 댓글을 달 수 있다.
</pre>

<h2>좋아요 버튼</h2>
<pre>
좋아요는 button을 클릭(submit)하게 되면 다시 그 창으로 redirect 시켜주고 좋아요를 업데이트 시켜준다.
좋아요 옆에는 좋아요 수가 뜨면서 사용자는 이 수를 보고 좋아요가 몇개인지 파악 가능하다.
게시글 상세로 들어가서 게시글을 본 후 뒤로가기 버튼으로 해당 게시글의 표지로 가게 유도한다.
좋아요는 게시글 상세(detail)에서 따로 form태그와 url를 만들어서 진행하였다.
</pre>

<h2>리다이렉트시에 url경로에 변수 넣기</h2>
<pre>
글을 등록하거나 수정하거나 삭제하는 경우에 url에 원하는 변수를 넣기위해서는
String url = "/user/board/" + id;
return "redirect:" + url; 
하면 된다.
</pre>

<h2>book과 board의 구조</h2>
<pre>
홈에서 'Editori 북' 탭으로 들어가게되면 출판물들의 '표지'가 뜬다. 
이것의 엔티티명을 'book'이라고 한다.
book 의 필드로 id, 제목, 작가, 카테고리 가 들어간다.
이 book을 하나 클릭하면 해당 book에 한 챕터씩 게시글이 나오는데 이것의 엔티티명을 board라 한다.
두개가 서로 연관을 맺고있는 구조를 띈다.
</pre>

